# Quest 2.5: Implement Bulk Actions with Throttling

## Status: Approved

## Quest

\* As an operator,  
\* I want to run or stop all currently visible automations at once,  
\* so that I can efficiently manage large groups of workflows.

## Acceptance Criteria (ACs)

1\.  Clicking "Run All Filtered" or "Stop All Filtered" shows a confirmation

```text
 dialog specifying the number of automations that will be affected.

```text

2\.  Upon confirmation, the frontend sends the list of all visible automation

```text
 IDs to a dedicated bulk action endpoint on the backend.

```text

3\.  The backend initiates the defined throttling mechanism: jobs are

```text
 processed in batches of max 200, with a 4-minute delay between each
 batch.

```text

4\.  The UI provides clear feedback on the bulk action's progress (e.g.,

```text
 "Running batch 1 of 5... Next batch in 3:59...").

```text

5\.  The backend process does not stop if a single workflow fails to trigger;

```text
 it continues processing the entire batch.

```text

6\.  After the final batch is processed, the backend returns a summary report,

```text
 including the total number of successes and a list of any specific
 failures.

```text

7\.  The UI displays this summary report to the user in a clear,

```text
 non-intrusive way (e.g., a toast notification).

```text

## Tasks / Subtasks

\- \[ \] \_\_Backend:\_\_ Create a new API route at

```text
   \`/src/app/api/automations/bulk-action/route.ts\`.

```text

\- \[ \] \_\_Backend:\_\_ The API route should accept a \`POST\` request with a

```text
   body containing an \`action\` ('run' or 'stop') and an array of
   \`automationIds\`.

```text

\- \[ \] \_\_Backend:\_\_ Implement the throttling and batching logic in a

```text
   service layer. The service should break the \`automationIds\` array into
   chunks of 200\.

```text

\- \[ \] \_\_Backend:\_\_ The service should process the first chunk, then wait

```text
   4 minutes before processing the next, and so on, until all chunks are
   complete. This must be handled as an asynchronous process.

```text

\- \[ \] \_\_Backend:\_\_ The service must collect a list of successes and

```text
   failures and return a final summary report in the API response.

```text

\- \[ \] \_\_Frontend:\_\_ In the \`AutomationsToolbar\` component, implement

```text
   the \`onClick\` handler for the "Run All Filtered" and "Stop All
   Filtered" buttons.

```text

\- \[ \] \_\_Frontend:\_\_ The handler should get the list of IDs from the

```text
   currently filtered automations.

```text

\- \[ \] \_\_Frontend:\_\_ On confirmation, the handler should call the new

```text
   \`/api/automations/bulk-action\` endpoint.

```text

\- \[ \] \_\_Frontend:\_\_ While the bulk action is processing, the UI should

```text
   show an indeterminate loading state (e.g., a spinning icon on the
   button).

```text

\- \[ \] \_\_Frontend:\_\_ When the final summary report is received from the

```text
   backend, display it to the user in a \`shadcn/ui\` Toast or Dialog.

```text

## Dev Notes

\_ \_\_Prerequisite:\_\* This quest requires Quest 2.2 (Filtering) and Quest
  2.3 (Backend for individual actions) to be complete.
\_ \_\_CRITICAL ARCHITECTURE NOTE:\_\* A long-running bulk action (e.g., 1000
  automations in 5 batches with a 4-minute delay \= 16+ minutes) will
  \_\_exceed the maximum execution time\_\_ for a standard Vercel serverless
  function. A simple \`await delay(240000)\` will fail. The architect must be
  consulted on the final implementation, which may require using a background
  job queue (e.g., Vercel Cron triggering jobs from a database queue) instead
  of a single, long-running API request. This quest defines the
  \_user-facing behavior\_; the technical implementation must be robust.
\_ \_\_UI Feedback:\_\* Clear feedback is essential. The bulk action buttons
  must be disabled while a bulk action is in progress to prevent multiple
  simultaneous requests.

## Testing

This quest requires \_\_Integration Tests\_\_ for the \`bulk-action\` API
endpoint and \_\_E2E Tests\_\_.

\_ \_\_Backend Integration Tests (Vitest):\_\*  

```text
\* Test that a large list of IDs is correctly broken into batches.  
\* Use fake timers (\`vi.useFakeTimers\`) to test the delay logic without
  actually waiting for minutes.
\* Test the partial failure case: the endpoint should still complete and
  the report should list the failures.

```text

\_ \_\_E2E Tests (Playwright):\_\*  

```text
\* Test the full user flow: filter the grid, click a bulk action button,
  confirm the dialog, and verify that the UI shows a processing state and
  eventually a completion message.

```text

## Manual Test Steps  

1\.  Navigate to the dashboard and filter the list to show 3-4 automations.  
2\.  Click "Run All Filtered." Verify the confirmation dialog shows the

```text
 correct count of automations.

```text

3\.  Confirm the action. The UI should indicate that a process is running,

```text
 and the button should be disabled.

```text

4\.  Check the Network tab to see the \`POST\` request to

```text
 \`/api/automations/bulk-action\`.

```text

5\.  Use \`webhook.site\` for the webhook URLs to verify that all automations

```text
 in the filtered list were triggered.

```text

6\.  Verify that the final summary report is displayed correctly in the UI.
